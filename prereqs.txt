Problem statement:

I need a way to have reminders pop up at defined times on my laptop. The solution should not involve external servers I do not have control over (i.e., google).

Requirments:

The input should be via simple text files. Perhaps I will consider adding an interface later that will allow these text files to be created automatically. I see this as being an extension to the simple journal files I keep, automating the to-do lists I occasionally create. Should input then be in one file that includes notes as well as reminder entries? For now I will keep things seperate, with one file containing the reminder entries.

The output should be fairly intrusive. Should it take up the full screen, be a pop up window in floating mode, a pop up window taking a space in whatever scheme is currently being used to organize windows? Let's say for now a full screened window, but if that is too difficult I can settle for something else to start. It would be nice if there was an interactive terminal interface (curses) that would allow me to review current reminders, edit them, and add new ones.

Analysis:

For the interface, I will use the ncurses library, which python has an interace for in it's standard library. As mentioned in the prevous section, I will store the data in text files. Well, if I am immediately going to an ncurses interface, I could consider python pickles or json formatted text files. It would be easier as I wouldn't have to construct a parser for the text files. Later I could consider adding a part that would search my notes files and add stuff. How will I have it able to run continously? The simplest thing would be to have a loop that sleeps for a period of time each iteration. I can start it manually each time the computer turns on. What makes something a daemon? This would be a daemon, as it is a continously running background process. Would the interface then be seperate process It would have to be, otherwise I would have to wait until the sleep part of the loop was done each time I want to access it. Is this a seperate program, a seperate file? I suppose so. This means I will have to be carefull about reading and writing files as the daemon might try and open them while they are being edited. What are the implications of this?

Apparently creating a daemon is not trivial. There is PEP document devoted to the topic (3143), which introduces a new module for the standard library. But actually it is extremely difficult to find anything written about it, and it doesn't seem to have ever made it to the standard library. I think I will be better of creating my own daemon class.

Eventually, I could consider adding an interface to systemctl so that it can automaticaly start things on boot. But for now I won't worry about that. Although I suppose it really makes no difference to how I design the program.

What are the main objects here? What are the abstract data-types I am working with? A reminder object, which has associated with it a time that a reminder should pop up, a time it should be done by, and the reminder itself. There will be the deamon object, which will need to spawn a background process that infintely loops, each time checking if there are new reminders, whether it is time to create a popup, and taking reminders off the list after the popup has been created. These should be still stored in the reminder file. Eventually I will come up with a better way to organize the reminders, but for now they will be either active or not. The times and dates are abstract data types but python already has classes in the standard library to deal with these. The pop up window will need to be a simple object itself. It might need to be considered a new process. So the daemon will need to be able to spawn new processes. I may be able to get with using the os module. Where should the file I/O be put? As a method on the reminder objects? Except I will need these methods to be accessed when no reminders are yet created. The methods for editing and creating new reminder objects will be in the interface program. But they should be seperate from the actual implementation of the interface. They can just be part of the reminder ojbects because each time I want to create a new reminder, an empty ojbect can be created and then the methods called on it. Maybe I will do them as pickles because then the daemon can just have a function to check for new ones and add them to the list.

So I will need to be able to use the following python standard library packages:

pickle
datetime
os (potentially subprocess)
fcntl (for file locking, wraps the linux program flock)
urwid (prev. curses)

There is another 3rd party library that wraps curses and provides an easier to use API; it's called urwid. I think I will try this first.

I could either update the reminder data structure or file every time the interface is updated during a session, or only at the end of the session. For now the former, to prevent cases of adding soon reminder and forgeting to close the program (which could also be solved by saving every x seconds).

Somehow the order that keypress is called has been mixed up. Now everything is fucked. How should I deal with the state variable now? I will need to have access to it at various levels.
